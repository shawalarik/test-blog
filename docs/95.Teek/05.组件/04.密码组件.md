---
title: å¯†ç ç»„ä»¶
date: 2025-10-9 15:15:43
permalink: /teek/password
coverImg: /home/bg03.webp
categories:
  - Teek
  - ç»„ä»¶
---

# å¯†ç ç»„ä»¶

æ­¤ç»„ä»¶æ˜¯ä¸€ä¸ªå¯†ç ç»„ä»¶  `PasswordProtect` ï¼Œæ”¯æŒæ ¹æ®è·¯å¾„è¿›è¡Œå¯†ç ä¿æŠ¤ï¼Œå¯†ç å­˜åœ¨äºæœ¬åœ° `localStorage` ä¸­ï¼ˆå­˜å‚¨æ•°æ®ç»è¿‡äº†åŠ å¯†ï¼‰

# PasswordProtect.vue

```vue
<template>
  <div class="password-protect-container">
    <div class="password-card">
      <!-- è¿”å›æŒ‰é’® -->
      <button class="back-btn" @click="handleBack" aria-label="è¿”å›ä¸Šä¸€é¡µ">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M19 12H5" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
          <path
            d="M12 19L5 12L12 5"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>

      <!-- æ ‡é¢˜åŒºåŸŸ -->
      <div class="card-header">
        <div class="lock-icon">ğŸ”’</div>
        <h2>éœ€è¦å¯†ç è®¿é—®</h2>
        <p class="subtitle">è¯¥å†…å®¹å—ä¿æŠ¤ï¼Œè¯·è¾“å…¥æ­£ç¡®å¯†ç </p>
      </div>

      <!-- è¾“å…¥åŒºåŸŸ -->
      <div class="input-group">
        <input
          v-model="input"
          type="password"
          @keyup.enter="submit"
          @input="handleInput"
          placeholder="è¯·è¾“å…¥å¯†ç "
          :class="{ invalid: error }"
          aria-label="å¯†ç è¾“å…¥æ¡†"
        />
        <p v-if="error" class="error-message">{{ error }}</p>
      </div>

      <!-- æŒ‰é’®åŒºåŸŸ -->
      <div class="button-group">
        <button class="submit-btn" @click="submit" :disabled="!input.trim()">ç¡®è®¤è®¿é—®</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";
import { useRouter } from "vitepress";

const router = useRouter();
const props = defineProps<{
  correctPassword: string;
  pageId: string;
}>();

// eslint-disable-next-line func-call-spacing
const emit = defineEmits<{
  (e: "verified", success: boolean): void;
}>();

const input = ref("");
const error = ref("");

// å¤„ç†è¾“å…¥ - è¿‡æ»¤ç©ºæ ¼
const handleInput = () => {
  input.value = input.value.replace(/\s+/g, ""); // ç§»é™¤æ‰€æœ‰ç©ºæ ¼
  if (error.value && input.value) {
    error.value = ""; // è¾“å…¥å†…å®¹æ—¶æ¸…é™¤é”™è¯¯æç¤º
  }
};

// æäº¤éªŒè¯
const submit = () => {
  const trimmedInput = input.value.trim();

  if (!trimmedInput) {
    error.value = "è¯·è¾“å…¥å¯†ç ";
    return;
  }

  if (trimmedInput === props.correctPassword) {
    emit("verified", true);
  } else {
    error.value = "å¯†ç é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥";
    input.value = "";
  }
};

// è¿”å›ä¸Šä¸€é¡µ
const handleBack = () => {
  // æ–¹æ¡ˆ1ï¼šä¼˜å…ˆä½¿ç”¨æµè§ˆå™¨åŸç”Ÿå†å²è®°å½•ï¼ˆæœ€ç¨³å®šï¼Œæ¨èï¼‰
  if (window.history.length > 1) {
    window.history.back(); // é€€å›ä¸Šä¸€é¡µï¼Œä¸åˆ·æ–°
  } else {
    // æ–¹æ¡ˆ2ï¼šè‹¥æ²¡æœ‰å†å²è®°å½•ï¼Œè·³è½¬åˆ°é¦–é¡µï¼ˆé¿å…å¡åœ¨å½“å‰é¡µï¼‰
    router.go("/");
  }

  // å¤‡ç”¨æ–¹æ¡ˆï¼šè‹¥éœ€ä¸¥æ ¼ä½¿ç”¨VitePressè·¯ç”±ï¼Œå¯æ›¿æ¢ä¸ºä»¥ä¸‹ä»£ç 
  // try {
  //   // éƒ¨åˆ†ç‰ˆæœ¬æ”¯æŒ router.go(-1)ï¼ˆå†å²è®°å½•åé€€1æ­¥ï¼‰
  //   router.go(-1);
  // } catch (e) {
  //   router.go("/"); // å¤±è´¥æ—¶å…œåº•è·³é¦–é¡µ
  // }
};
</script>

<style scoped>
.password-protect-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  padding: 1rem;
  box-sizing: border-box;
  position: relative;
  background-color: var(--vp-c-bg);
  --error-color: orangered;
}

/* å¡ç‰‡å®¹å™¨ */
.password-card {
  position: relative;
  z-index: 2;
  width: 100%;
  max-width: 420px;
  background: var(--vp-c-bg-soft);
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
  padding: 2.5rem 2rem;
  border: 1px solid var(--vp-c-divider);
  transition: transform 0.3s ease;
}

/*.password-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.12);
}*/

/* è¿”å›æŒ‰é’® */
.back-btn {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: transparent;
  border: none;
  color: var(--vp-c-text-2);
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 6px;
  transition: all 0.2s ease;
}

.back-btn:hover {
  color: var(--vp-c-brand);
  background: var(--vp-c-bg);
}

/* æ ‡é¢˜åŒºåŸŸ */
.card-header {
  text-align: center;
  margin-bottom: 2rem;
}

.lock-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
  opacity: 0.8;
}

.card-header h2 {
  margin: 0 0 0.5rem 0;
  color: var(--vp-c-text-1);
  font-size: 1.5rem;
  font-weight: 600;
}

.subtitle {
  margin: 0;
  color: var(--vp-c-text-2);
  font-size: 0.95rem;
  line-height: 1.5;
}

/* è¾“å…¥åŒºåŸŸ */
.input-group {
  margin-bottom: 1.5rem;
}

.input-group input {
  width: 100%;
  padding: 0.9rem 1rem;
  font-size: 1rem;
  border: 1px solid var(--vp-c-divider);
  border-radius: 8px;
  background: var(--vp-c-bg);
  color: var(--vp-c-text-1);
  box-sizing: border-box;
  transition: all 0.2s ease;
}

.input-group input::placeholder {
  color: var(--vp-c-text-3);
}

.input-group input:focus {
  outline: none;
  border-color: var(--vp-c-brand);
  box-shadow: 0 0 0 3px rgba(55, 118, 203, 0.1);
}

.input-group input.invalid {
  border-color: var(--error-color);
}

.error-message {
  margin: 0.5rem 0 0 0;
  color: var(--error-color);
  font-size: 0.85rem;
  text-align: left;
  padding-left: 0.25rem;
  animation: shake 0.5s ease;
}

/* æŒ‰é’®åŒºåŸŸ */
.button-group {
  margin-top: 1rem;
}

.submit-btn {
  width: 100%;
  padding: 0.9rem 1rem;
  font-size: 1rem;
  font-weight: 500;
  border: none;
  border-radius: 8px;
  background: var(--vp-c-brand);
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
}

.submit-btn:hover {
  transform: translateY(-2px);
}

.submit-btn:hover:not(:disabled) {
  background: dodgerblue;
}

.submit-btn:active:not(:disabled) {
  transform: translateY(0);
}

.submit-btn:disabled {
  background: dodgerblue;
  cursor: not-allowed;
  opacity: 0.7;
}

/* é”™è¯¯åŠ¨ç”» */
@keyframes shake {
  0%,
  100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-5px);
  }
  75% {
    transform: translateX(5px);
  }
}

/* å“åº”å¼è°ƒæ•´ */
@media (max-width: 480px) {
  .password-card {
    padding: 2rem 1.5rem;
  }

  .card-header h2 {
    font-size: 1.3rem;
  }

  .lock-icon {
    font-size: 2.5rem;
  }
}
</style>

```



# util.ts

å¯ä»¥é…ç½®é»˜è®¤çš„å¯†ç ä¿æŠ¤è§„åˆ™

```ts
import { ref, watch } from "vue";
import { useData, useRouter } from "vitepress";
import { isClient } from "vitepress-theme-teek";

// ========================= æ ¸å¿ƒé…ç½®ï¼ˆåŠ¡å¿…ä¿®æ”¹ï¼ï¼‰=========================
const ENCRYPTION_KEY = "your-32-char-key-here-12345678";
const SALT = new TextEncoder().encode("vp-protect-salt-2024");
const PBKDF2_ITERATIONS = 1000;
const LOCAL_STORAGE_KEY: string = "tk:vpVerifiedPages";

// é»˜è®¤ä¿æŠ¤è§„åˆ™ï¼ˆæ”¯æŒå‰ç¼€åŒ¹é…ä¸€æ¬¡æ€§éªŒè¯ï¼‰
export const DEFAULT_PROTECTED_ROUTES: ProtectedRoute[] = [
  { path: "/private/*", password: "secret123" },
  { path: "/archives", password: "123" }
];

// ========================= ç±»å‹å®šä¹‰ =========================
export interface ProtectedRoute {
  path: string;
  password: string;
}

// ========================= å·¥å…·å‡½æ•°ï¼šBase64ç¼–è§£ç  =========================
const uint8ToBase64 = (array: Uint8Array): string => {
  return btoa(String.fromCharCode(...array))
    .replace(/\+/g, "-")
    .replace(/\//g, "_")
    .replace(/=+$/, "");
};

const base64ToUint8 = (str: string): Uint8Array => {
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  const pad = str.length % 4;
  if (pad) str += "=".repeat(4 - pad);

  const binary = atob(str);
  const array = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    array[i] = binary.charCodeAt(i);
  }
  return array;
};

// ========================= åŠ å¯†æ ¸å¿ƒå‡½æ•° =========================
const generateVerifyKey = async (key: string): Promise<string> => {
  const encoder = new TextEncoder();
  const data = encoder.encode(`${key}::${ENCRYPTION_KEY}`);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return uint8ToBase64(new Uint8Array(hashBuffer));
};

const getEncryptionKey = async (): Promise<CryptoKey> => {
  const encoder = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey("raw", encoder.encode(ENCRYPTION_KEY), { name: "PBKDF2" }, false, [
    "deriveKey"
  ]);

  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt: SALT, iterations: PBKDF2_ITERATIONS, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
};

const encryptData = async (data: string[]): Promise<string> => {
  try {
    const key = await getEncryptionKey();
    const encoder = new TextEncoder();
    const jsonStr = JSON.stringify(data);
    const dataBuffer = encoder.encode(jsonStr);
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, dataBuffer);
    const encryptedArray = new Uint8Array(encrypted);
    const authTag = encryptedArray.slice(-16);
    const ciphertext = encryptedArray.slice(0, -16);

    return `${uint8ToBase64(iv)}|${uint8ToBase64(ciphertext)}|${uint8ToBase64(authTag)}`;
  } catch (e) {
    console.error("åŠ å¯†å¤±è´¥:", e);
    throw new Error("éªŒè¯çŠ¶æ€å­˜å‚¨å¤±è´¥");
  }
};

const decryptData = async (encryptedStr: string): Promise<string[]> => {
  try {
    const [ivBase64, ciphertextBase64, authTagBase64] = encryptedStr.split("|");
    if (!ivBase64 || !ciphertextBase64 || !authTagBase64) {
      throw new Error("æ•°æ®æ ¼å¼æ— æ•ˆ");
    }

    const iv = base64ToUint8(ivBase64);
    const ciphertext = base64ToUint8(ciphertextBase64);
    const authTag = base64ToUint8(authTagBase64);
    // ç»„åˆå¯†æ–‡å’Œè®¤è¯æ ‡ç­¾
    const encrypted = new Uint8Array([...ciphertext, ...authTag]);

    const key = await getEncryptionKey();
    // eslint-disable-next-line no-undef
    const decryptedBuffer = await crypto.subtle.decrypt({ name: "AES-GCM", iv: iv as BufferSource }, key, encrypted);
    const decryptedStr = new TextDecoder().decode(decryptedBuffer);
    return JSON.parse(decryptedStr) as string[];
  } catch (e) {
    console.warn("è§£å¯†å¤±è´¥:", e);
    localStorage.removeItem(LOCAL_STORAGE_KEY);
    return [];
  }
};

// ========================= æ ¸å¿ƒé€»è¾‘ï¼šæŒ‰è·¯å¾„å‰ç¼€ç®¡ç†éªŒè¯çŠ¶æ€ =========================
/**
 * 1. åŒ¹é…å½“å‰è·¯å¾„å¯¹åº”çš„ä¿æŠ¤è§„åˆ™ï¼ˆè¿”å›è§„åˆ™+å‰ç¼€æ ‡è¯†ï¼‰
 * ä¾‹ï¼š/front/docs â†’ åŒ¹é… /front/* è§„åˆ™ï¼Œè¿”å› { rule, prefix: "/front" }
 */
const matchProtectedRule = (
  currentPath: string,
  protectedRoutes: ProtectedRoute[]
): { rule: ProtectedRoute | null; prefix: string | null } => {
  for (const rule of protectedRoutes) {
    // å¤„ç†å‰ç¼€åŒ¹é…ï¼ˆå¦‚ /front/*ï¼‰
    if (rule.path.endsWith("/*")) {
      const prefix = rule.path.slice(0, -1); // æå–å‰ç¼€ï¼š/front/* â†’ /front
      // éªŒè¯å½“å‰è·¯å¾„æ˜¯å¦ä»¥è¯¥å‰ç¼€å¼€å¤´ï¼ˆä¸”ä¸æ˜¯å‰ç¼€æœ¬èº«ï¼Œé¿å…åŒ¹é… /frontï¼‰
      if (currentPath.startsWith(prefix) && currentPath !== prefix) {
        return { rule, prefix };
      }
    }
    // å¤„ç†ç²¾ç¡®åŒ¹é…ï¼ˆå¦‚ /archivesï¼‰
    else if (currentPath === rule.path) {
      return { rule, prefix: rule.path }; // ç²¾ç¡®è·¯å¾„çš„å‰ç¼€å°±æ˜¯è‡ªèº«
    }
  }
  return { rule: null, prefix: null };
};

/**
 * 2. è·å–å·²éªŒè¯çš„å‰ç¼€/è·¯å¾„é›†åˆ
 */
const getVerifiedPrefixes = async (): Promise<Set<string>> => {
  if (!isClient) return new Set();

  try {
    const encryptedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!encryptedData) return new Set();

    const verifiedHashes = await decryptData(encryptedData);
    return new Set(verifiedHashes);
  } catch (e) {
    console.warn("è·å–éªŒè¯çŠ¶æ€å¤±è´¥:", e);
    localStorage.removeItem(LOCAL_STORAGE_KEY);
    return new Set();
  }
};

/**
 * 3. æ ‡è®°å‰ç¼€/è·¯å¾„ä¸ºå·²éªŒè¯ï¼ˆä¸€æ¬¡æ€§éªŒè¯æ ¸å¿ƒï¼šå­˜å‚¨å‰ç¼€è€Œéå•ä¸ªé¡µé¢ï¼‰
 */
const markPrefixAsVerified = async (prefix: string): Promise<void> => {
  if (!isClient) return;

  try {
    // ç”Ÿæˆå‰ç¼€çš„åŠ å¯†å“ˆå¸Œï¼ˆé¿å…æ‰‹åŠ¨ç¯¡æ”¹ï¼‰
    const prefixHash = await generateVerifyKey(prefix);
    const verifiedPrefixes = await getVerifiedPrefixes();
    verifiedPrefixes.add(prefixHash);

    // åŠ å¯†å­˜å‚¨å‰ç¼€å“ˆå¸Œé›†åˆ
    const encryptedData = await encryptData(Array.from(verifiedPrefixes));
    localStorage.setItem(LOCAL_STORAGE_KEY, encryptedData);
  } catch (e) {
    console.warn("æ ‡è®°éªŒè¯çŠ¶æ€å¤±è´¥:", e);
    throw new Error("éªŒè¯çŠ¶æ€å­˜å‚¨å¤±è´¥ï¼Œè¯·é‡è¯•");
  }
};

/**
 * 4. æ£€æŸ¥å½“å‰é¡µé¢æ˜¯å¦éœ€è¦å¯†ç ï¼ˆæŒ‰å‰ç¼€éªŒè¯ï¼‰
 */
const shouldShowPassword = async (
  currentPath: string,
  frontmatterPassword: string | undefined,
  protectedRoutes: ProtectedRoute[] = DEFAULT_PROTECTED_ROUTES
): Promise<{ show: boolean; password: string | null; verifyPrefix: string | null }> => {
  // ä¼˜å…ˆå¤„ç†frontmatterå¯†ç ï¼ˆå•ä¸ªé¡µé¢ç‹¬ç«‹éªŒè¯ï¼‰
  if (frontmatterPassword) {
    const verifyKey = currentPath; // ç²¾ç¡®é¡µé¢è·¯å¾„
    const verifiedPrefixes = await getVerifiedPrefixes();
    const verifyKeyHash = await generateVerifyKey(verifyKey);
    const isVerified = verifiedPrefixes.has(verifyKeyHash);

    return {
      show: !isVerified,
      password: frontmatterPassword,
      verifyPrefix: verifyKey // å­˜å‚¨çš„æ˜¯å•ä¸ªé¡µé¢è·¯å¾„
    };
  }

  // å¤„ç†è·¯ç”±è§„åˆ™ï¼ˆå‰ç¼€/ç²¾ç¡®åŒ¹é…ï¼‰
  const { rule, prefix } = matchProtectedRule(currentPath, protectedRoutes);
  if (!rule || !prefix) {
    return { show: false, password: null, verifyPrefix: null };
  }

  // æ£€æŸ¥è¯¥å‰ç¼€æ˜¯å¦å·²éªŒè¯
  const verifiedPrefixes = await getVerifiedPrefixes();
  const prefixHash = await generateVerifyKey(prefix);
  const isVerified = verifiedPrefixes.has(prefixHash);

  return {
    show: !isVerified,
    password: rule.password,
    verifyPrefix: prefix // å­˜å‚¨çš„æ˜¯å‰ç¼€ï¼ˆå¦‚ /frontï¼‰
  };
};

// ========================= æ ¸å¿ƒHook =========================
export function usePasswordProtection(customRoutes?: ProtectedRoute[]) {
  const { frontmatter } = useData();
  const router = useRouter();

  const showPassword = ref(false);
  const currentPassword = ref("");
  const currentVerifyPrefix = ref<string | null>(null); // æ”¹ä¸ºå­˜å‚¨ã€ŒéªŒè¯å‰ç¼€ã€è€Œéé¡µé¢ID
  const isChecking = ref(false);

  // æ£€æŸ¥é¡µé¢ä¿æŠ¤çŠ¶æ€
  const checkProtection = async (path: string) => {
    if (!isClient) return;

    isChecking.value = true;
    try {
      const fmPassword = frontmatter.value?.password as string | undefined;
      const routes = customRoutes || DEFAULT_PROTECTED_ROUTES;
      const result = await shouldShowPassword(path, fmPassword, routes);

      showPassword.value = result.show;
      currentPassword.value = result.password || "";
      currentVerifyPrefix.value = result.verifyPrefix; // è®°å½•éœ€è¦éªŒè¯çš„å‰ç¼€
    } catch (e) {
      console.error("æ£€æŸ¥é¡µé¢ä¿æŠ¤çŠ¶æ€å¤±è´¥:", e);
    } finally {
      isChecking.value = false;
    }
  };

  // ç›‘å¬è·¯ç”±å˜åŒ–ï¼ˆåˆ‡æ¢/front/*ä¸‹é¡µé¢æ—¶è‡ªåŠ¨æ£€æŸ¥ï¼‰
  watch(
    () => router.route.path,
    async newPath => {
      if (isClient) {
        await checkProtection(newPath);
      }
    },
    { immediate: true }
  );

  // å¤„ç†éªŒè¯æˆåŠŸï¼ˆæ ‡è®°å‰ç¼€ä¸ºå·²éªŒè¯ï¼‰
  const handleVerified = async (success: boolean) => {
    if (success && currentVerifyPrefix.value && !isChecking.value) {
      try {
        await markPrefixAsVerified(currentVerifyPrefix.value);
        showPassword.value = false;
      } catch (e) {
        alert("éªŒè¯æˆåŠŸï¼Œä½†çŠ¶æ€å­˜å‚¨å¤±è´¥ï¼Œè¯·é‡æ–°å°è¯•");
      }
    }
  };

  return {
    showPassword,
    currentPassword,
    currentVerifyPrefix,
    isChecking,
    handleVerified
  };
}

```



# é…ç½®

åœ¨`docs/.vitepress/theme/index.ts`ä¸­è¿›è¡Œé…ç½®ï¼Œä½¿ç”¨å¯†ç ç»„ä»¶

```ts
  Layout: defineComponent({
    name: "LayoutProvider",
    setup() {
      const props: { class?: string } = {};
      const { frontmatter } = useData();

      // æ ¹æ®å…ƒæ•°æ®åŠ¨æ€åº”ç”¨ CSS ç±»ï¼Œå®ç°é¡µé¢çº§æ ·å¼å®šåˆ¶
      if (frontmatter.value?.layoutClass) {
        props.class = frontmatter.value.layoutClass;
      }

      const { showPassword, currentPassword, currentVerifyPrefix, handleVerified } = usePasswordProtection();

      // æ¸²æŸ“å‡½æ•°
      return () => {
        if (showPassword.value) {
          return h(PasswordProtect, {
            correctPassword: currentPassword.value,
            pageId: currentVerifyPrefix.value,
            onVerified: handleVerified
          });
        }

        // æ­£å¸¸æ¸²æŸ“ Teek å¸ƒå±€
        return h(TeekLayoutProvider, props);
      };
    }
  }),
```

